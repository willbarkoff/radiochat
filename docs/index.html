<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Radiochat</title>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
</head>

<body>
    <div class="container mt-5">
        <div class="row">
            <div class="col-4 d-none d-md-block">
                <nav id="nav" class="position-fixed h-100 flex-column align-items-stretch pe-4">
                    <nav class="nav nav-underline flex-column">
                        <a class="nav-link py-0" href="#introduction">Introduction</a>
                        <a class="nav-link py-0" href="#packet-radio">Packet Radio & LoRa</a>
                        <a class="nav-link py-0" href="#tcpip">TCP/IP</a>
                        <a class="nav-link py-0 ms-4" href="#dhcp">DHCP</a>
                        <a class="nav-link py-0 ms-4" href="#dns">DNS</a>
                        <a class="nav-link py-0 ms-4" href="#http">HTTP</a>
                        <a class="nav-link py-0" href="#software-design">Software Design</a>
                        <a class="nav-link py-0" href="#hardware">Hardware</a>
                        <a class="nav-link py-0" href="#conclusions">Conclusions</a>
                        <a class="nav-link py-0" href="#appendices">Appendices</a>
                    </nav>
                </nav>
            </div>

            <div class="col-xs-12 col-md-8">
                <div data-bs-spy="scroll" data-bs-target="#nav" data-bs-smooth-scroll="true" tabindex="0">
                    <div class="pt-5 px-5 bg-body-tertiary rounded-top-3">
                        <div class="container-fluid py-5">
                            <div class="container">
                                <h1 class="display-5 fw-bold">Radiochat</h1>
                                
                                <p class="col-md-8 fs-4">
                                    Communicate over radio frequencies using your phone!
                                </p>
                                <div class="buttons">
                                    <a href="https://github.com/willbarkoff/radiochat" class="btn btn-primary btn-lg"
                                        target="_blank">
                                        Source code</a>
                                    <a href="https://www.youtube.com/watch?v=zv5Eqr0OXQg" class="btn btn-primary btn-lg"
                                        target="_blank">
                                        Demo
                                    </a>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="mb-5 p-2 px-5 bg-body-secondary rounded-bottom-3">
                        <div class="container-fluid">
                            <div class="container">
                                <p class="fs-5 my-2">
                                    <img src="./img/pfp-square.jpg" width="50" class="rounded-circle me-2">
                                    <a class="link-dark" href="https://willbarkoff.dev"><strong>William Barkoff</strong></a>
                                </p>
                            </div>
                        </div>
                    </div>
                    
                    </div>

                    <div id="introduction">
                        <h2>Introduction</h2>
                        <p>
                            Radiochat is a device that pairs to any other device with a browser over WiFi, and can be
                            used to transmit and receive LoRa messages. This has a number of practical applications,
                            notably, the Radiochat device can be paired to mobile phones, and messages can be exchanged
                            using the devices in locations without WiFi or cellular networks.
                        </p>

                        <p>
                            My inspiration to build Radiochat came from a practical experience. I am a member of the <a
                                href="https://cornellrocketryteam.com">Cornell Rocketry Team</a>, and our team travels
                            to remote locations in New Mexico to launch our rockets. These locations often do not have
                            cellular service or WiFi, and we need an effective way to communicate. In the past, we have
                            used handheld radios, but communicating precise numbers over handheld radios can be
                            difficult. Packet radio provides an effective way to handle this communication.
                        </p>

                        <figure class="figure">
                            <img src="img/white-sands.jpg" class="figure-img img-fluid rounded" alt="...">
                            <figcaption class="figure-caption">
                                White Sands National Park, a few miles from where we launch our rocket. Photo &copy;
                                2023 William Barkoff, all rights reserved.
                            </figcaption>
                        </figure>
                    </div>
                    <div id="packet-radio">
                        <h2>Packet Radio & LoRa</h2>
                        <p>
                            Radio, in the way that most people think of it, involved transmitting sounds over the air.
                            Usually, this is done by modulating the frequency (FM actually stands for "frequency
                            modulation") or modulating the amplitude (AM stands for "amplitude modulation") of the sine
                            wave.
                        </p>

                        <figure class="">
                            <div class="ratio ratio-16x9">
                                <iframe src="https://www.desmos.com/calculator/x1enqz3bag?embed"></iframe>
                            </div>
                            <figcaption class="figure-caption">
                                AM and FM modulations of a sine wave.
                            </figcaption>
                        </figure>

                        <p>
                            This works really well for analog signals, like sounds, but works less well for
                            digital signals. There are a number of modulation schemes for digital signals, morse code
                            (or CW, as it is called in the amateur radio community) being one of the oldest and most
                            famous!
                        </p>

                        <p>
                            One of these modulation schemes is LoRa (which is actually short for Long Range). LoRa is a
                            proprietary (Patent <a
                                href="https://patents.google.com/patent/US9647718B2/en">US9647718B2</a>) modulation
                            scheme developed by Semtech. LoRa uses spread-spectrum techniques (meaning that the signal
                            is broadcast over multiple frequencies) to broadcast data over radio waves. It's commonly
                            used in IoT devices, especially those in remote locations because LoRa waves can travel over
                            large distances.
                        </p>

                        <p>
                            I used the <a href="https://github.com/jgromes/RadioLib">RadioLib</a> library to perform the
                            LoRa broadcasts, and the RFM96W module, which includes the hardware necessary for LoRa
                            modulation. RadioLib is written for Arduino, so getting it to work on the Pico required some
                            additional work. RadioLib has support for hardware abstraction, so I wrote a RadioLib
                            Hardware Abstraction Layer for the Raspberry Pi Pico. This allowed RadioLib to work with the
                            Pico's GPIO devices, including its SPI buses, its interrupts, and its timers. This HAL is
                            implemented in the <a
                                href="https://github.com/willbarkoff/radiochat/blob/main/PicoHAL.hpp">PicoHAL.hpp</a>
                            file in the source code.
                        </p>
                    </div>
                    <div id="tcpip">
                        <h2>TCP/IP</h2>
                        <p>
                            Unfortunately, the internet as a technology is quite complicated. When talking about the
                            internet, we often discuss the Internet Protocol Suite (sometimes referred to as TCP/IP, two
                            of the protocols in the suite, the Transmission Control Protocol and the Internet Protocol).
                            TCP/IP is split into four different layers:
                        </p>
                        <ul>
                            <li>
                                The <strong>Link Layer</strong> defines how computers physically connect to other
                                computers. It defines protocols like Ethernet (<a
                                    href="https://datatracker.ietf.org/doc/html/rfc894">RFC 894</a>
                                and <a href="https://ieeexplore.ieee.org/document/9844436">IEEE 802.3</a>). The main
                                document that defines the Link layer is <a
                                    href="https://datatracker.ietf.org/doc/html/rfc1122#section-2">RFC 1122</a>. It is
                                the lowest layer on the internet stack. To use the post office as an analogy, the link
                                layer is the trucks, boats, and planes that transport the mail around the world.
                            </li>
                            <li>
                                The <strong>Internet Layer</strong> sits on top of the Link Layer. It's also defined in
                                <a href="https://datatracker.ietf.org/doc/html/rfc1122#section-3">RFC 1122</a>. It
                                defines how the simplest packets are sent between computers, or "hosts." It doesn't
                                explain what these packets contain or when they're sent, just how to transport them to
                                get to their intended destination. It defines protocols like IP (as in <em>IP
                                    address</em>, <a href="https://datatracker.ietf.org/doc/html/rfc791">RFC 791</a>).
                                The internet layer is just about getting packets from one host to another. It doesn't
                                make sure that the packet wasn't corrupted, or that several packets were received in
                                order, or even that no packets were dropped.
                            </li>
                            <li>
                                The <strong>Transport Layer</strong> sits on top of the Internet Layer. It defines
                                protocols like TCP (<a href="https://datatracker.ietf.org/doc/html/rfc9293">RFC
                                    9293</a>) and UDP (<a href="https://datatracker.ietf.org/doc/html/rfc768">RFC
                                    768</a>). These protocols handle the things that the internet layer doesn't handle:
                                packet reordering, fixing corruption, sending acknowledgments, and more.
                            </li>
                            <li>
                                Finally, the <strong>Application Layer</strong> handles many of the actual messages
                                being sent. It defines protocols like HTTP (<a
                                    href="https://datatracker.ietf.org/doc/html/rfc9110">RFC 9110</a>, <a
                                    href="https://datatracker.ietf.org/doc/html/rfc9111">RFC 9111</a> and <a
                                    href="https://httpwg.org/specs/">others</a>), FTP (RFC <a
                                    href="https://datatracker.ietf.org/doc/html/rfc959">RFC 959</a>), and even
                                SMTP (used for sending emails, <a
                                    href="https://datatracker.ietf.org/doc/html/rfc821">RFC 821</a>). HTTP is very
                                commonly used for communication over the web.
                            </li>
                        </ul>
                        <p>
                            Each of these protocols are developed on paper. It's up to the developer of each system to
                            implement them. Many protocols are already implement in the Pico SDK's standard library, and
                            in the Lightweight IP library; however, there are a few that you must implement, mostly in
                            the application layer.
                        </p>
                        <p>
                            Here's an example of a DNS request TCP/IP packet, which I'll go more into later.
                        </p>

                        <pre>
                            <code>
0000   <span class="py-1 bg-info-subtle">08 00 00 00 00 00 00 01 03 04 00 06 00 00 00 00</span>   <span class="py-1 bg-info-subtle">................</span>
0010   <span class="py-1 bg-info-subtle">00 00 00 00</span> <span class="py-1 bg-danger-subtle">45 00 00 50 59 09 00 00 40 11 23 5e</span>   <span class="py-1 bg-info-subtle">....</span><span class="py-1 bg-danger-subtle">E..PY...@.#^</span>
0020   <span class="py-1 bg-danger-subtle">7f 00 00 01 7f 00 00 35</span> <span class="py-1 bg-success-subtle">a1 96 00 35 00 3c fe 83</span>   <span class="py-1 bg-danger-subtle">.......5</span><span class="py-1 bg-success-subtle">...5.<..</span>
0030   <span class="py-1 bg-warning-subtle">cd dc 01 20 00 01 00 00 00 00 00 01 07 65 78 61</span>   <span class="py-1 bg-warning-subtle">... .........exa</span>
0040   <span class="py-1 bg-warning-subtle">6d 70 6c 65 03 63 6f 6d 00 00 01 00 01 00 00 29</span>   <span class="py-1 bg-warning-subtle">mple.com.......)</span>
0050   <span class="py-1 bg-warning-subtle">04 d0 00 00 00 00 00 0c 00 0a 00 08 31 fc 8e 8c</span>   <span class="py-1 bg-warning-subtle">............1...</span>
0060   <span class="py-1 bg-warning-subtle">e7 4a 66 f3</span>                                       <span class="py-1 bg-warning-subtle">.Jf.</span>
                            </code>
                        </pre>

                        <p>
                            This is a hex dump. On the left, we see each byte of the response, represented in
                            hexadecimal. On the right, we see the ASCII character represented by each byte, if it is
                            printable. Otherwise, it is a <code>.</code> character.
                        </p>

                        <p>
                            I've colored each of the different protocols being used in the response in a different
                            color.
                        <ul>
                            <li>
                                <span class="py-1 bg-info-subtle">Link Layer - <strong>Linux Cooked Capture
                                        v2</strong></span> is in
                                blue. I captured outgoing packet locally on my computer, before it was sent to the
                                network card, where it would be replaced by an Ethernet packet. It specifies the
                                destination hardware address for the packet, and my computer's hardware address (I
                                zeroed both out for privacy). I would be sending the packet to another computer that my
                                machine is physically connected to, likely the router. The router would then replace
                                this part of the packet with the next machine that it is sending this packet to, likely
                                a modem.
                            </li>
                            <li>
                                <span class="py-1 bg-danger-subtle">Internet Layer - <strong>Internet
                                        Protocol v4</strong></span> is in red. It includes my IP address, 127.0.0.1
                                (<code>7f 00 00 01</code>) (because this packet was captured locally), and the IP
                                address that the packet is going to, 127.0.0.35 (<code>7f 00 00 35</code>).
                            </li>
                            <li>
                                <span class="py-1 bg-success-subtle">Transport Layer - <strong>User Datagram
                                        Protocol</strong></span> is in green. It includes the source port (41366,
                                <code>a1 96</code>), and the destination port (53, <code>00 35</code>). It also includes
                                the message length (60, <code>00 3c</code>), and a checksum to make sure that the
                                message is intact (<code>fe 83</code>).
                            </li>
                            <li>
                                <span class="py-1 bg-warning-subtle">Application Layer - <strong>Domain Name System
                                        Query</strong></span> is in yellow. I'll go through how the Domain Name System
                                works later on.
                            </li>

                        </ul>
                        </p>
                    </div>
                    <div id="dhcp">
                        <h3>DHCP</h3>
                        <p>
                            The <strong>Dynamic Host Configuration Protocol</strong> (DHCP, <a
                                href="https://datatracker.ietf.org/doc/html/rfc2131">RFC 2131</a>) is an
                            application-layer protocol used to assign IP addresses to hosts. The Pico W SDK has the
                            necessary code to serve as a wireless access point (meaning that it can broadcast it's own
                            network), but a DHCP server needs to be implemented so that hosts can connect to the
                            network.
                        </p>

                        <figure class="position-relative">
                            <pre class="mermaid">
                                sequenceDiagram
                                    Client->>+Server: Discover: DHCPDISCOVER
                                    Server->>+Client: Offer: DHCPOFFER
                                    Client->>+Server: Request: DHCPREQUEST
                                    Server->>+Client: Acknowledge: DHCPACK
                            </pre>
                            <figcaption class="figure-caption">
                                DHCP IP address assignment protocol.
                            </figcaption>
                        </figure>


                        <p>
                            It takes four steps to get a DHCP address, as shown in the diagram above. Each of these
                            messages is transmitted over UDP.
                        </p>
                        <ol>
                            <li>
                                First, the client, which doesn't know the DHCP server's IP address, broadcasts a
                                <code>DHCPDISCOVER</code> message to the IP address <code>255.255.255.255</code>. This
                                message includes the hardware (MAC) address of the client making the request (field
                                <code>CHADDR</code>, for client hardware address), and a magic cookie, the value
                                <code>0x63825363</code>, which identifies the message as a DHCP request.
                            </li>
                            <li>
                                Next, the server responds with a <code>DHCPOFFER</code> message. It includes two more
                                fields, <code>YIADDR</code>, your IP address, the new IP address being offered to the
                                client, and <code>SIADDR</code>, server IP address, the IP address of the DHCP server.
                                It also includes the <code>CHADDR</code>, so the client knows that the packet is
                                intended for it. It also includes the magic cookie.
                            </li>
                            <li>
                                Now the client knows an IP address that is available! It needs to request that IP
                                address to claim it. It uses a <code>DHCPREQUEST</code> message to do so. This DHCP
                                message just includes <code>SIADDR</code>, <code>CHADDR</code>, and a special field,
                                DHCP option 50, which specifies the IP address being requested, the one that was
                                received in the <code>YIADDR</code> field of the <code>DHCPOFFER</code> message. It also
                                includes the magic cookie.
                            </li>
                            <li>
                                Finally, the DHCP server needs to acknowledge the request! It sends back a
                                <code>DHCPACK</code> message to do so. It inclues <code>SIADDR</code>,
                                <code>CHADDR</code>, <code>YIADDR</code>, and DHCP option 51, which specifies the amount
                                of time that the client can lease the IP address for. After the lease expires, the
                                client must request a new IP address using DHCP.
                            </li>
                        </ol>
                        <p>
                            I ended up using the <a
                                href="https://github.com/willbarkoff/radiochat/blob/main/dhcpserver">DHCP library from
                                the Micro Python project</a> (MIT licensed), but spending time understanding how DHCP
                            works helped me a lot in debugging the network aspects of the project.
                        </p>

                    </div>
                    <div id="dns">
                        <h3>DNS</h3>
                        <p>
                            One of the other parts of the TCP/IP stack that you need to implement to host a network from
                            the Pico W is a DNS server. DNS is the <strong>Domain Name System</strong>, used to map
                            domain names, such as <code>example.com</code>, to IP addresses, such as
                            <code>93.184.216.34</code>. The <code>dig</code> command can be used to make a DNS request,
                            which becomes useful in testing.
                            </pre>
                        </p>
                        <p>
                            Normally, DNS works by making recursive queries to other DNS servers, until some DNS server
                            finds the IP address associated with a domain name; however, for my use case, this wasn't
                            necessary, as every domain needed to resolve to the same host: the Pico W. Therefore, we
                            only need the front-end of the DNS server&mdash;we don't actually need to look up IP
                            addresses to respond with.
                        </p>
                        <p>
                            To better understand DNS, I thought that it would be a good idea to simply look at a DNS
                            request. To get the DNS request, I used <code>tcpdump</code> to get the DNS traffic for my
                            computer for one request generated by <code>DiG</code>: <code>dig example.com</code>.
                        </p>
                        <figure class="figure">
                            <img src="img/wireshark.png" class="figure-img img-fluid rounded" alt="...">
                            <figcaption class="figure-caption">
                                The two UDP packets that I captured, the first one outgoing, and the second one
                                incoming.
                            </figcaption>
                        </figure>

                        <p>
                            As you can see, there are two packets, one outgoing, and one incoming. Let's take a closer
                            look at the outgoing packet (it's the same packet that we looked at earlier), but this time,
                            let's only look at the DNS section. (I also ran out of distinguishable colors, so this time,
                            I'm going to mark it up with a pen)
                        </p>


                        <figure class="figure">
                            <a href="img/annotated-dns.jpg"><img src="img/annotated-dns.jpg"
                                    class="figure-img img-fluid rounded" alt=""></a>
                            <figcaption class="figure-caption">
                                Annotated DNS packet. Click for larger image. <a href="img/dns-cap.pcap">Download
                                    wireshark capture.</a>
                            </figcaption>
                        </figure>

                        <p>
                            The response follows a very similar format, except it contains an answer rather than a
                            question! The answer simply contains the IP address of the host, and some additional
                            information.
                        </p>

                        <p>
                            I also ended up using <a
                                href="https://github.com/willbarkoff/radiochat/tree/main/dnsserver">a library</a> for
                            DNS requests. It was provided in one of the pico-examples, which are licensed under the
                            BSD-3-Clause license.
                        </p>

                    </div>
                    <div id="http">
                        <h3>HTTP</h3>
                        <p>
                            The last internet suite protocol that I had to implement was the Hypertext Transfer
                            Protocol, or HTTP. HTTP is used to send files over the internet. Most commonly, it's used
                            for websites.
                        </p>
                        <p>
                            I actually knew a lot about HTTP from older projects of mine. In fact, I once <a
                                href="https://willbarkoff.dev/2020/06/18/hackdalton">ran a CTF/programming
                                competiton</a>, and <a
                                href="https://github.com/HackDalton/problem2020-homemade-http/blob/master/WRITEUP.md">one
                                of the problems that I wrote involved handwriting HTTP requests.</a>
                        </p>
                        <p>
                            One of the best things about HTTP requests is how simple they are. HTTP only uses ASCII
                            printable characters. Let's take a look at an HTTP request.
                        </p>

                        <pre><code>
GET /index.html HTTP/1.1
Host: example.com</code></pre>

                        <p>
                            As you can see, the request is incredibly simple. This is a <code>GET</code> request, used
                            just to get data. <code>GET</code> requests are not allowed to change the state of the
                            server. The path to the file that we're getting is <code>/index.html</code>, and we're using
                            HTTP version 1.1. The host that we're requesting from is <code>example.com</code>.
                        </p>

                        <p>
                            The information that follows the first line of the request are headers. Each header has a
                            name, starting with a capital letter, and a value. The name and value are separated by a
                            colon and a space. <code>Host</code> is not the only header in most requests; however, it is
                            the only header that you need to send a <code>GET</code> request.
                        </p>

                        <p>
                            Now, let's look at the response.
                        </p>

                        <pre><code>HTTP/1.1 200 OK
Accept-Ranges: bytes
Age: 549055
Cache-Control: max-age=604800
Content-Type: text/html; charset=UTF-8
Date: Mon, 18 Dec 2023 01:36:08 GMT
Etag: "3147526947+gzip"
Expires: Mon, 25 Dec 2023 01:36:08 GMT
Last-Modified: Thu, 17 Oct 2019 07:18:26 GMT
Server: ECS (nyb/1D10)
Vary: Accept-Encoding
X-Cache: HIT
Content-Length: 1256

&lt;!doctype html&gt;
...
                            </code></pre>

                        <p>
                            As you can see, the response follows a similar format to the request. Again, there are only
                            a few important parts. <code>HTTP/1.1</code> is the version of HTTP that we're using, and
                            200 OK is the response code. There are <a
                                href="https://datatracker.ietf.org/doc/html/rfc9110">many response codes to choose
                                from</a>, each conveying a different meaning. The only required headers are
                            <code>Content-Type</code>, which conveys to the client the <a
                                href="https://www.iana.org/assignments/media-types/media-types.xhtml">MIME type</a> of
                            the content being sent back, and <code>Content-Length</code>, which contains the length of
                            the data being sent back.
                        </p>
                        <p>
                            When implementing the HTTP code, I started with the HTTP server found in pico-examples.
                            Unfortunately, that server only supported GET requests. GET requests are only meant to fetch
                            information, and not change the state of the server, and there's good reason for this! Many
                            browsers issue GET requests for other links on a page, even if you don't click them. That
                            way, these pages seem to load faster when you do click them (a technique called <a
                                href="https://developer.mozilla.org/en-US/docs/Glossary/Prefetch">prefetching</a>).
                        </p>
                        <p>
                            If you change state or perform actions on a GET request, you may inadvertently perform these
                            actions during a prefetch request. There is a classic story of someone who connected their
                            garage door opener to an HTTP server, and used GET requests to open and close it. The person
                            also bookmarked the page to open and close it, and their browser prefetched their bookmarks
                            on a new tab. Each time they opened a new tab, their garage door opened or closed! I
                            didn't want LoRa messages to be sent inadvertently, so, I also needed to implement another
                            request type on the server, POST requests.
                        </p>
                        <p>
                            POST requests are often used to update data, in fact, HTML <code>&lt;form&gt;</code>
                            elements can automatically issue POST requests when they're submitted, so I didn't need to
                            implement any JavaScript.
                        </p>
                        <p>
                            Implementing POST requests was somewhat similar to how the server implemented GET requests,
                            but there was a little extra complexity due to having to account for request bodies,
                            contained in POST requests but not in GET requests. Due to space constraints on the
                            microcontroller, I only support POST requests up to <code>2048</code> bytes in size,
                            including headers. This is a bit unfortunate, but a limitation due to the space available on
                            the RP2040.
                        </p>
                    </div>
                    <div id="software-design">
                        <h2>Software Design</h2>
                        <p>
                            The software design for this project was relatively simple. I split the work into two parts:
                            the web server and the radio. Each was done on a different core. There were two shared
                            resources between the cores, a buffer that had the last message that the radio received, and
                            a buffer that had the next message to transmit (if there is one).
                        </p>
                        <p>
                            The Radio would attempt to listen for a message for 500 ms. If it heard the beginning of a
                            LoRa packet, it would continue listening, otherwise, it would stop listening, and check to
                            see if there was a message to transmit. If there is a message to transmit, it would transmit
                            the message. Otherwise, it would return to listening.
                        </p>
                        <p>
                            I first tried to use the hardware spinlocks on the RP2040 to ensure that only one thread
                            could access each buffer at a time, but I couldn't get them to work correctly. I ended up
                            simply using a one-bit flag and and the <code>volitale</code> keyword to determine if a new
                            message was ready to transmit. I did not end up fixing the race condition on the receive
                            buffer, but I was never able to replicate that error. If the error did occur in practice, it
                            could be fixed immediately by the end-user reloading the page.
                        </p>
                    </div>

                    <div id="hardware">
                        <h2>Hardware</h2>
                        <figure class="figure">
                            <img src="img/hardware.jpg" class="figure-img img-fluid rounded" alt="...">
                            <figcaption class="figure-caption">
                                The hardware of the device.
                            </figcaption>
                        </figure>
                        <p>
                            Hardware design for this project was also very simple. The radio module was connected over
                            SPI to the Pico W, and communicated over SPI, with two interrupt pins.
                        </p>
                        <p>
                            One of the first issues that I ran into was that I was unable to communicate with the radio.
                            I used a logic analyzer to attempt to debug the SPI lines, but my SPI packets matched the
                            datasheet, and I was getting what seemed to be random values back. Finally, I noticed that
                            the reset pin on the radio module was active high instead of active low, so I was holding
                            the radio in reset. Pulling the reset pin high fixed the issue.
                        </p>
                    </div>
                    <div id="conclusions">
                        <h2>Conclusions</h2>
                        <p>
                            Overall, the design worked very well! I am happy with the results. If I had more time, I
                            would like to implement websocket communication, so you don't need to reload the page to
                            receive data from the page. Additionally, I would like to make the web interface nicer,
                            which would likely require more space on the Pico. This could be solved by attaching
                            external flash memory, and using that to store extra data.
                        </p>
                        <p>
                            There is also a bug with Darwin-based operating systems sending messages. I believe that it
                            is a line-termination problem, as Darwin operating systems send LF at the end of an HTTP
                            request, while most other operating systems (including Linux) send CRLF. I hope to test this
                            more in the future, but unfortunately, I do not have a Mac that I can use to test it
                            available. An alternative would be switching to Bluetooth based communication, and
                            developing a mobile companion app.
                        </p>
                        <p>
                            I learned a lot from this project, even though I used some external libraries and starter
                            code. It has been really interesting to implement such a complex system when you're so
                            resource constrained. As some next steps, I hope to print a PCB, clean up the code, and fix
                            the few bugs that I mentioned so that hopefully, I can use the system more effectively.
                        </p>
                    </div>

                    <div id="appendices">
                        <h2>Appendices</h2>
                        <h4>Appendix A: Permissions</h4>
                        <ul>
                            <li>The group approves this report for inclusion on the course website.</li>
                            <li>The group approves the video for inclusion on the course youtube channel.</li>
                            <li>
                                The content of this webpage is licensed under the <a
                                    href="https://willbarkoff.dev/licenses/cc-by-nc-nd.html"> Creative Commons
                                    Attribution-NonCommercial-NoDerivatives 4.0 International Public License
                                    (CC-BY-NC-ND 4.0)</a>. Attribution is required in redistributions.
                            </li>
                        </ul>
                        <h4>Appendix B: References</h4>
                        <ul>
                            <li> Richard Sharpe, Ed Warnicke, Ulf Lamping. <em><a
                                        href="https://www.wireshark.org/docs/wsug_html/">Wireshark User's
                                        Guide</a></em>,
                                Wireshark.
                            </li>
                            <li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP">HTTP</a>, Mozilla Developer
                                Network</li>
                            <li><a href="https://www.iana.org/assignments/media-types/media-types.xhtml">Media
                                    Types</a>, Internet Assigned Numbers Authority</li>
                            <li><a href="https://developer.mozilla.org/en-US/docs/Glossary/Prefetch">Prefetching</a>,
                                Mozilla Developer Network</li>
                            <li><a href="https://datatracker.ietf.org/doc/html/rfc1035">RFC 1035: Domain names -
                                    implementation and specification</a>, Internet Engineering Task Force</li>
                            <li><a href="https://datatracker.ietf.org/doc/html/rfc1122">RFC 1122: Requirements for
                                    Internet Hosts - Communication Layers</a>, Internet Engineering Task Force</li>
                            <li><a href="https://datatracker.ietf.org/doc/html/rfc2131">RFC 2131: Dynamic Host
                                    Configuration Protocol</a>, Internet Engineering Task Force</li>
                            <li><a href="https://github.com/jgromes/RadioLib">RadioLib</a>, Jan Gromeš</li>
                            <li><a href="https://patents.google.com/patent/US9647718B2/en">Wireless communication
                                    method</a>, Olivier Bernard André Seller</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
</body>

</html>